/*
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.aggregate.tools.generateinputs;

import static com.google.common.collect.ImmutableList.toImmutableList;

import com.beust.jcommander.JCommander;
import com.beust.jcommander.Parameter;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.google.aggregate.adtech.worker.model.AggregatedFact;
import com.google.aggregate.adtech.worker.model.Fact;
import com.google.aggregate.adtech.worker.model.Payload;
import com.google.aggregate.adtech.worker.model.serdes.cbor.CborPayloadSerdes;
import com.google.aggregate.adtech.worker.writer.avro.LocalAvroResultFileWriter;
import com.google.aggregate.protocol.avro.AvroOutputDomainRecord;
import com.google.aggregate.protocol.avro.AvroOutputDomainWriter;
import com.google.aggregate.protocol.avro.AvroOutputDomainWriterFactory;
import com.google.aggregate.protocol.avro.AvroReportRecord;
import com.google.aggregate.protocol.avro.AvroReportWriter;
import com.google.aggregate.protocol.avro.AvroReportWriterFactory;
import com.google.aggregate.shared.mapper.GuavaObjectMapper;
import com.google.auto.value.AutoValue;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.io.BaseEncoding;
import com.google.common.io.ByteSource;
import com.google.inject.AbstractModule;
import com.google.inject.Guice;
import com.google.inject.Injector;
import java.io.IOException;
import java.io.OutputStream;
import java.io.UncheckedIOException;
import java.math.BigInteger;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Collection;
import java.util.Optional;
import java.util.stream.Stream;

/**
 * Reads Raw JSON debug reports generated by Chrome or other clients and produces corresponding
 * files for aggregate service.
 *
 * <p>This expects an input directory containing JSON files of reports. Each file should contain one
 * report.
 *
 * <p>This generates the following files:
 *
 * <p>1. Avro input file of encrypted reports: encrypted_reports.avro
 *
 * <p>2. Avro input file of plaintext reports: plaintext_reports.avro
 *
 * <p>3. Avro output domain file for the reports: domain.avro
 *
 * <p>4. Avro results file of the expected output without any noise: unnoised_result.avro
 *
 * <p>Run the following for command line usage:
 *
 * <p>bazel run //java/com/google/aggregate/tools/generateinputs:GenerateInputs -- --help
 */
public final class GenerateInputs {

  private static final Injector injector = Guice.createInjector(new GenerateInputsModule());

  private static final AvroReportWriterFactory avroReportWriterFactory =
      injector.getInstance(AvroReportWriterFactory.class);
  private static final CborPayloadSerdes cborPayloadSerdes =
      injector.getInstance(CborPayloadSerdes.class);
  private static final AvroOutputDomainWriterFactory avroOutputDomainWriterFactory =
      injector.getInstance(AvroOutputDomainWriterFactory.class);
  private static final ObjectMapper objectMapper = injector.getInstance(GuavaObjectMapper.class);
  private static final LocalAvroResultFileWriter localAvroResultFileWriter =
      injector.getInstance(LocalAvroResultFileWriter.class);

  public static void main(String[] args) throws Exception {

    InputArgs inputArgs = new InputArgs();
    JCommander jCommander = JCommander.newBuilder().addObject(inputArgs).build();

    if (args == null || args.length == 0) {
      usage(jCommander);
      return;
    }

    jCommander.parse(args);
    if (inputArgs.help) {
      usage(jCommander);
      return;
    }

    Path reportsPath = Path.of(inputArgs.inputDir).toAbsolutePath();
    Path outputBasePath = Path.of(inputArgs.outputDir).toAbsolutePath();

    // Read inputs
    ImmutableList<FullAggregatableReport> fullAggregatableReports =
        Files.list(reportsPath)
            .map(
                path -> {
                  try {
                    return objectMapper.readValue(path.toFile(), FullAggregatableReport.class);
                  } catch (IOException e) {
                    throw new UncheckedIOException(e);
                  }
                })
            .collect(toImmutableList());

    // Create AvroReportRecords for encrypted reports to be written
    ImmutableList<AvroReportRecord> avroEncryptedReportRecords =
        fullAggregatableReports.stream()
            .flatMap(
                fullAggregatableReport ->
                    fullAggregatableReport.aggregationServicePayloads().stream()
                        .map(
                            payload ->
                                AvroReportRecord.create(
                                    /* payload= */ base64Decode(payload.payload()),
                                    /* keyId= */ payload.keyId(),
                                    /* sharedInfo= */ fullAggregatableReport.sharedInfo())))
            .collect(toImmutableList());

    // Write encrypted reports avro file (1)
    Path encryptedReportsOutputPath = outputBasePath.resolve("encrypted_reports.avro");
    try (OutputStream outputAvroStream = Files.newOutputStream(encryptedReportsOutputPath);
        AvroReportWriter reportWriter = avroReportWriterFactory.create(outputAvroStream)) {
      reportWriter.writeRecords(/* metadata= */ ImmutableList.of(), avroEncryptedReportRecords);
    }
    System.out.println("Wrote " + encryptedReportsOutputPath);

    // Create AvroReportRecords for plaintext reports to be written
    ImmutableList<AvroReportRecord> avroPlaintextReportRecords =
        fullAggregatableReports.stream()
            .flatMap(
                fullAggregatableReport ->
                    fullAggregatableReport.aggregationServicePayloads().stream()
                        .map(
                            payload ->
                                AvroReportRecord.create(
                                    /* payload= */ base64Decode(payload.debugClearTextPayload()),
                                    /* keyId= */ "unused",
                                    /* sharedInfo= */ fullAggregatableReport.sharedInfo())))
            .collect(toImmutableList());

    // Write plaintext reports avro file (2)
    Path plaintextReportsOutputPath = outputBasePath.resolve("plaintext_reports.avro");
    try (OutputStream outputAvroStream = Files.newOutputStream(plaintextReportsOutputPath);
        AvroReportWriter reportWriter = avroReportWriterFactory.create(outputAvroStream)) {
      reportWriter.writeRecords(/* metadata= */ ImmutableList.of(), avroPlaintextReportRecords);
    }
    System.out.println("Wrote " + plaintextReportsOutputPath);

    // Generate corresponding output domain and unnoised output: deserialize debugClearTextPayloads
    Stream<Payload> payloads =
        fullAggregatableReports.stream()
            .map(FullAggregatableReport::aggregationServicePayloads)
            .flatMap(Collection::stream)
            .map(
                aggregationServicePayload ->
                    base64Decode(aggregationServicePayload.debugClearTextPayload()))
            .map(cborPayloadSerdes::convert)
            .filter(Optional::isPresent)
            .map(Optional::get);

    // Generate corresponding output domain and unnoised output: aggregate values from payloads
    ImmutableMap<BigInteger, Long> aggregatedBuckets =
        payloads
            .map(Payload::data)
            .flatMap(Collection::stream)
            .collect(ImmutableMap.toImmutableMap(Fact::bucket, Fact::value, Long::sum));

    // Write the corresponding output domain (3)
    Path domainOutputPath = outputBasePath.resolve("domain.avro");
    try (OutputStream outputAvroStream = Files.newOutputStream(domainOutputPath);
        AvroOutputDomainWriter outputDomainWriter =
            avroOutputDomainWriterFactory.create(outputAvroStream)) {
      ImmutableList<AvroOutputDomainRecord> outputDomainRecords =
          aggregatedBuckets.keySet().stream()
              .map(AvroOutputDomainRecord::create)
              .collect(toImmutableList());
      outputDomainWriter.writeRecords(ImmutableList.of(), outputDomainRecords);
    }
    System.out.println("Wrote " + domainOutputPath);

    // Write the expected unnoised output (4)
    Stream<AggregatedFact> aggregatedFacts =
        aggregatedBuckets.entrySet().stream()
            .map(entry -> AggregatedFact.create(entry.getKey(), entry.getValue()));
    Path unnoisedResultsPath = outputBasePath.resolve("unnoised_result.avro");
    localAvroResultFileWriter.writeLocalFile(aggregatedFacts, unnoisedResultsPath);
    System.out.println("Wrote " + unnoisedResultsPath);
  }

  private static void usage(JCommander jCommander) {
    jCommander.setProgramName(GenerateInputs.class.getName());
    jCommander.usage();
  }

  private static ByteSource base64Decode(String message) {
    return ByteSource.wrap(BaseEncoding.base64().decode(message));
  }

  private static class GenerateInputsModule extends AbstractModule {}

  private static final class InputArgs {

    @Parameter(
        names = "--reports_dir",
        description =
            "The directory containing the input reports. This expects that each file in the"
                + " directory contains a single JSON report.",
        required = true)
    private String inputDir;

    @Parameter(
        names = "--output_dir",
        description = "The directory to write outputs to. 4 avro files will be written.",
        required = true)
    private String outputDir;

    @Parameter(names = "--help", help = true, description = "Print help dialog and exit.")
    private boolean help = false;
  }

  /**
   * Matches
   * https://github.com/WICG/attribution-reporting-api/blob/main/AGGREGATE.md#aggregatable-reports
   */
  @AutoValue
  @JsonDeserialize(builder = FullAggregatableReport.Builder.class)
  @JsonSerialize(as = FullAggregatableReport.class)
  abstract static class FullAggregatableReport {

    public static Builder builder() {
      return new AutoValue_GenerateInputs_FullAggregatableReport.Builder();
    }

    @JsonProperty("aggregation_service_payloads")
    public abstract ImmutableList<AggregationServicePayload> aggregationServicePayloads();

    @JsonProperty("shared_info")
    public abstract String sharedInfo();

    @AutoValue.Builder
    @JsonIgnoreProperties(ignoreUnknown = true)
    public abstract static class Builder {

      @JsonCreator
      public static Builder builder() {
        return new AutoValue_GenerateInputs_FullAggregatableReport.Builder();
      }

      @JsonProperty("aggregation_service_payloads")
      public abstract Builder setAggregationServicePayloads(
          ImmutableList<AggregationServicePayload> value);

      @JsonProperty("shared_info")
      public abstract Builder setSharedInfo(String value);

      public abstract FullAggregatableReport build();
    }
  }

  @AutoValue
  @JsonDeserialize(builder = AggregationServicePayload.Builder.class)
  @JsonSerialize(as = AggregationServicePayload.class)
  abstract static class AggregationServicePayload {

    public static Builder builder() {
      return new AutoValue_GenerateInputs_AggregationServicePayload.Builder();
    }

    @JsonProperty("debug_cleartext_payload")
    public abstract String debugClearTextPayload();

    @JsonProperty("key_id")
    public abstract String keyId();

    @JsonProperty("payload")
    public abstract String payload();

    @AutoValue.Builder
    @JsonIgnoreProperties(ignoreUnknown = true)
    public abstract static class Builder {

      @JsonCreator
      public static Builder builder() {
        return new AutoValue_GenerateInputs_AggregationServicePayload.Builder();
      }

      @JsonProperty("debug_cleartext_payload")
      public abstract Builder setDebugClearTextPayload(String value);

      @JsonProperty("key_id")
      public abstract Builder setKeyId(String value);

      @JsonProperty("payload")
      public abstract Builder setPayload(String value);

      public abstract AggregationServicePayload build();
    }
  }
}
