diff --git a/java/com/google/scp/operator/cpio/cryptoclient/DecryptionKeyServiceImpl.java b/java/com/google/scp/operator/cpio/cryptoclient/DecryptionKeyServiceImpl.java
index a7a4fbcee..cdecb81b3 100644
--- a/java/com/google/scp/operator/cpio/cryptoclient/DecryptionKeyServiceImpl.java
+++ b/java/com/google/scp/operator/cpio/cryptoclient/DecryptionKeyServiceImpl.java
@@ -27,6 +27,7 @@ import com.google.crypto.tink.KeysetHandle;
 import com.google.inject.Inject;
 import com.google.scp.operator.cpio.cryptoclient.PrivateKeyFetchingService.PrivateKeyFetchingServiceException;
 import com.google.scp.operator.cpio.cryptoclient.model.ErrorReason;
+import com.google.scp.shared.api.exception.ServiceException;
 import java.io.IOException;
 import java.security.GeneralSecurityException;
 import java.util.concurrent.ExecutionException;
@@ -59,11 +60,13 @@ public final class DecryptionKeyServiceImpl implements DecryptionKeyService {
                                 privateKeyFetchingService.fetchKeyCiphertext(keyId)),
                             aead);
                     return keySetHandle.getPrimitive(HybridDecrypt.class);
-                  } catch (IOException
-                      | GeneralSecurityException
-                      | PrivateKeyFetchingServiceException e) {
+                  } catch (PrivateKeyFetchingServiceException e) {
+                    throw generateKeyFetchException(e);
+                  } catch (IOException e) {
                     throw new KeyFetchException(
                         "Failed to fetch key ID: " + keyId, ErrorReason.UNKNOWN_ERROR, e);
+                  } catch (GeneralSecurityException e) {
+                    throw new KeyFetchException(e, ErrorReason.KEY_DECRYPTION_ERROR);
                   }
                 }
               });
@@ -81,7 +84,28 @@ public final class DecryptionKeyServiceImpl implements DecryptionKeyService {
     try {
       return decypterCache.get(keyId);
     } catch (ExecutionException | UncheckedExecutionException e) {
-      throw new KeyFetchException("Failed to get key ID: " + keyId, ErrorReason.UNKNOWN_ERROR, e);
+      ErrorReason reason = ErrorReason.UNKNOWN_ERROR;
+      if (e.getCause() instanceof KeyFetchException) {
+        reason = ((KeyFetchException) e.getCause()).getReason();
+      }
+      throw new KeyFetchException("Failed to get key with id: " + keyId, reason, e);
     }
   }
+
+  private static KeyFetchException generateKeyFetchException(PrivateKeyFetchingServiceException e) {
+    if (e.getCause() instanceof ServiceException) {
+      switch (((ServiceException) e.getCause()).getErrorCode()) {
+        case NOT_FOUND:
+          return new KeyFetchException(e, ErrorReason.KEY_NOT_FOUND);
+        case PERMISSION_DENIED:
+        case UNAUTHENTICATED:
+          return new KeyFetchException(e, ErrorReason.PERMISSION_DENIED);
+        case INTERNAL:
+          return new KeyFetchException(e, ErrorReason.INTERNAL);
+        default:
+          return new KeyFetchException(e, ErrorReason.UNKNOWN_ERROR);
+      }
+    }
+    return new KeyFetchException(e, ErrorReason.UNKNOWN_ERROR);
+  }
 }
diff --git a/java/com/google/scp/operator/cpio/cryptoclient/MultiPartyDecryptionKeyServiceImpl.java b/java/com/google/scp/operator/cpio/cryptoclient/MultiPartyDecryptionKeyServiceImpl.java
index 15faaa175..74c329222 100644
--- a/java/com/google/scp/operator/cpio/cryptoclient/MultiPartyDecryptionKeyServiceImpl.java
+++ b/java/com/google/scp/operator/cpio/cryptoclient/MultiPartyDecryptionKeyServiceImpl.java
@@ -38,6 +38,7 @@ import com.google.scp.operator.cpio.cryptoclient.Annotations.CoordinatorAAead;
 import com.google.scp.operator.cpio.cryptoclient.Annotations.CoordinatorBAead;
 import com.google.scp.operator.cpio.cryptoclient.EncryptionKeyFetchingService.EncryptionKeyFetchingServiceException;
 import com.google.scp.operator.cpio.cryptoclient.model.ErrorReason;
+import com.google.scp.shared.api.exception.ServiceException;
 import com.google.scp.shared.crypto.tink.CloudAeadSelector;
 import com.google.scp.shared.util.KeySplitUtil;
 import java.io.IOException;
@@ -95,7 +96,11 @@ public final class MultiPartyDecryptionKeyServiceImpl implements DecryptionKeySe
     try {
       return decypterCache.get(keyId);
     } catch (ExecutionException | UncheckedExecutionException e) {
-      throw new KeyFetchException("Failed to get key ID: " + keyId, ErrorReason.UNKNOWN_ERROR, e);
+      ErrorReason reason = ErrorReason.UNKNOWN_ERROR;
+      if (e.getCause() instanceof KeyFetchException) {
+        reason = ((KeyFetchException) e.getCause()).getReason();
+      }
+      throw new KeyFetchException("Failed to get key with id: " + keyId, reason, e);
     }
   }

@@ -127,7 +132,11 @@ public final class MultiPartyDecryptionKeyServiceImpl implements DecryptionKeySe
               "Unsupported encryption key type.", ErrorReason.UNKNOWN_ERROR);
       }

-    } catch (IOException | GeneralSecurityException | EncryptionKeyFetchingServiceException e) {
+    } catch (EncryptionKeyFetchingServiceException e) {
+      throw generateKeyFetchException(e);
+    } catch (GeneralSecurityException e) {
+      throw new KeyFetchException(e, ErrorReason.KEY_DECRYPTION_ERROR);
+    } catch (IOException e) {
       throw new KeyFetchException("Failed to fetch key ID: " + keyId, ErrorReason.UNKNOWN_ERROR, e);
     }
   }
@@ -171,4 +180,22 @@ public final class MultiPartyDecryptionKeyServiceImpl implements DecryptionKeySe
         .findFirst()
         .get();
   }
+
+  private static KeyFetchException generateKeyFetchException(
+      EncryptionKeyFetchingServiceException e) {
+    if (e.getCause() instanceof ServiceException) {
+      switch (((ServiceException) e.getCause()).getErrorCode()) {
+        case NOT_FOUND:
+          return new KeyFetchException(e, ErrorReason.KEY_NOT_FOUND);
+        case PERMISSION_DENIED:
+        case UNAUTHENTICATED:
+          return new KeyFetchException(e, ErrorReason.PERMISSION_DENIED);
+        case INTERNAL:
+          return new KeyFetchException(e, ErrorReason.INTERNAL);
+        default:
+          return new KeyFetchException(e, ErrorReason.UNKNOWN_ERROR);
+      }
+    }
+    return new KeyFetchException(e, ErrorReason.UNKNOWN_ERROR);
+  }
 }
diff --git a/java/com/google/scp/operator/cpio/cryptoclient/model/ErrorReason.java b/java/com/google/scp/operator/cpio/cryptoclient/model/ErrorReason.java
index 214df01d5..bcb1874e5 100644
--- a/java/com/google/scp/operator/cpio/cryptoclient/model/ErrorReason.java
+++ b/java/com/google/scp/operator/cpio/cryptoclient/model/ErrorReason.java
@@ -18,7 +18,13 @@ package com.google.scp.operator.cpio.cryptoclient.model;

 /** Error reasons for crypto client. */
 public enum ErrorReason {
-  // Permission was denied.
+  // Internal error, caused by unexpected server-side exceptions.
+  INTERNAL,
+  // Unable to decrypt key, caused by error in KMS tool
+  KEY_DECRYPTION_ERROR,
+  // Key not found error, caused by HTTP 404 error on private key endpoint when key is not found
+  KEY_NOT_FOUND,
+  // Permission was denied, caused by HTTP 403 error on private key endpoint.
   PERMISSION_DENIED,
   // An unknown fatal error occurred.
   UNKNOWN_ERROR,
diff --git a/java/com/google/scp/operator/cpio/cryptoclient/testing/FakePrivateKeyFetchingService.java b/java/com/google/scp/operator/cpio/cryptoclient/testing/FakePrivateKeyFetchingService.java
index a9ec56521..f113eb1ad 100644
--- a/java/com/google/scp/operator/cpio/cryptoclient/testing/FakePrivateKeyFetchingService.java
+++ b/java/com/google/scp/operator/cpio/cryptoclient/testing/FakePrivateKeyFetchingService.java
@@ -17,17 +17,27 @@
 package com.google.scp.operator.cpio.cryptoclient.testing;

 import com.google.scp.operator.cpio.cryptoclient.PrivateKeyFetchingService;
+import com.google.scp.shared.api.exception.ServiceException;
+import com.google.scp.shared.api.model.Code;

 /** Fake PrivateKeyFetchingService which returns a preconfigured response. */
 public final class FakePrivateKeyFetchingService implements PrivateKeyFetchingService {

   private String response = "";
+  private boolean throwException = false;
+  private Code errorCause = Code.UNKNOWN;
+  private String errorMessage = "";

   /**
    * Returns the response set by the {@code setResponse} method, or an empty String if it was not
    * set.
    */
-  public String fetchKeyCiphertext(String keyId) {
+  public String fetchKeyCiphertext(String keyId) throws PrivateKeyFetchingServiceException {
+    if (throwException) {
+      throwException = false;
+      throw new PrivateKeyFetchingServiceException(
+          new ServiceException(errorCause, "Test Exception", errorMessage));
+    }
     return response;
   }

@@ -35,4 +45,15 @@ public final class FakePrivateKeyFetchingService implements PrivateKeyFetchingSe
   public void setResponse(String newResponse) {
     response = newResponse;
   }
+
+  /**
+   * Set this instance to throw a ServiceException the next time fetchKeyCiphertext is called.
+   *
+   * @param code Code to set the ErrorCause in the thrown ServiceException to
+   */
+  public void setExceptionContents(Code code, String message) {
+    throwException = true;
+    errorCause = code;
+    errorMessage = message;
+  }
 }
diff --git a/javatests/com/google/scp/operator/cpio/cryptoclient/BUILD b/javatests/com/google/scp/operator/cpio/cryptoclient/BUILD
index ddeef013f..7d29f7c2b 100644
--- a/javatests/com/google/scp/operator/cpio/cryptoclient/BUILD
+++ b/javatests/com/google/scp/operator/cpio/cryptoclient/BUILD
@@ -51,6 +51,7 @@ java_test(
     srcs = ["DecryptionKeyServiceImplTest.java"],
     deps = [
         "//java/com/google/scp/operator/cpio/cryptoclient",
+        "//java/com/google/scp/shared/api/model",
         "//java/external:acai",
         "//java/external:google_truth",
         "//java/external:guice",
@@ -68,6 +69,8 @@ java_test(
         "//coordinator/protos/keymanagement/keyhosting/api/v1:java_proto",
         "//coordinator/protos/keymanagement/shared/api/v1:java_proto",
         "//java/com/google/scp/operator/cpio/cryptoclient",
+        "//java/com/google/scp/shared/api/exception",
+        "//java/com/google/scp/shared/api/model",
         "//java/com/google/scp/shared/crypto/tink",
         "//java/com/google/scp/shared/util",
         "//java/external:acai",
diff --git a/javatests/com/google/scp/operator/cpio/cryptoclient/DecryptionKeyServiceImplTest.java b/javatests/com/google/scp/operator/cpio/cryptoclient/DecryptionKeyServiceImplTest.java
index a53fa3b25..ee12f7cd4 100644
--- a/javatests/com/google/scp/operator/cpio/cryptoclient/DecryptionKeyServiceImplTest.java
+++ b/javatests/com/google/scp/operator/cpio/cryptoclient/DecryptionKeyServiceImplTest.java
@@ -17,6 +17,8 @@
 package com.google.scp.operator.cpio.cryptoclient;

 import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertThrows;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.when;

@@ -25,7 +27,10 @@ import com.google.crypto.tink.Aead;
 import com.google.crypto.tink.HybridDecrypt;
 import com.google.inject.AbstractModule;
 import com.google.inject.Inject;
+import com.google.scp.operator.cpio.cryptoclient.DecryptionKeyService.KeyFetchException;
+import com.google.scp.operator.cpio.cryptoclient.model.ErrorReason;
 import com.google.scp.operator.cpio.cryptoclient.testing.FakePrivateKeyFetchingService;
+import com.google.scp.shared.api.model.Code;
 import com.google.scp.shared.testutils.crypto.MockTinkUtils;
 import java.util.UUID;
 import org.junit.Before;
@@ -70,6 +75,100 @@ public class DecryptionKeyServiceImplTest {
         .isEqualTo(plaintext.getBytes());
   }

+  @Test
+  public void getDecrypter_errorWithCode_NOT_FOUND() throws Exception {
+    keyFetchingService.setExceptionContents(Code.NOT_FOUND, /* message= */ "");
+    keyFetchingService.setResponse(mockTinkUtils.getAeadKeySetJson());
+    when(aead.decrypt(any(byte[].class), any(byte[].class)))
+        .thenReturn(mockTinkUtils.getDecryptedKey());
+    when(aead.encrypt(any(byte[].class), any(byte[].class)))
+        .thenReturn(mockTinkUtils.getEncryptedKey());
+    String plaintext = "test_plaintext";
+    byte[] cipheredText = mockTinkUtils.getCiphertext(plaintext);
+
+    KeyFetchException exception =
+        assertThrows(
+            KeyFetchException.class,
+            () -> decryptionKeyServiceImpl.getDecrypter(UUID.randomUUID().toString()));
+
+    assertEquals(exception.getReason(), ErrorReason.KEY_NOT_FOUND);
+  }
+
+  @Test
+  public void getDecrypter_errorWithCode_PERMISSION_DENIED() throws Exception {
+    keyFetchingService.setExceptionContents(Code.PERMISSION_DENIED, /* message= */ "");
+    keyFetchingService.setResponse(mockTinkUtils.getAeadKeySetJson());
+    when(aead.decrypt(any(byte[].class), any(byte[].class)))
+        .thenReturn(mockTinkUtils.getDecryptedKey());
+    when(aead.encrypt(any(byte[].class), any(byte[].class)))
+        .thenReturn(mockTinkUtils.getEncryptedKey());
+    String plaintext = "test_plaintext";
+    byte[] cipheredText = mockTinkUtils.getCiphertext(plaintext);
+
+    KeyFetchException exception =
+        assertThrows(
+            KeyFetchException.class,
+            () -> decryptionKeyServiceImpl.getDecrypter(UUID.randomUUID().toString()));
+
+    assertEquals(exception.getReason(), ErrorReason.PERMISSION_DENIED);
+  }
+
+  @Test
+  public void getDecrypter_errorWithCode_INTERNAL() throws Exception {
+    keyFetchingService.setExceptionContents(Code.INTERNAL, /* message= */ "");
+    keyFetchingService.setResponse(mockTinkUtils.getAeadKeySetJson());
+    when(aead.decrypt(any(byte[].class), any(byte[].class)))
+        .thenReturn(mockTinkUtils.getDecryptedKey());
+    when(aead.encrypt(any(byte[].class), any(byte[].class)))
+        .thenReturn(mockTinkUtils.getEncryptedKey());
+    String plaintext = "test_plaintext";
+    byte[] cipheredText = mockTinkUtils.getCiphertext(plaintext);
+
+    KeyFetchException exception =
+        assertThrows(
+            KeyFetchException.class,
+            () -> decryptionKeyServiceImpl.getDecrypter(UUID.randomUUID().toString()));
+
+    assertEquals(exception.getReason(), ErrorReason.INTERNAL);
+  }
+
+  @Test
+  public void getDecrypter_errorWithCode_default() throws Exception {
+    keyFetchingService.setExceptionContents(Code.UNKNOWN, /* message= */ "");
+    keyFetchingService.setResponse(mockTinkUtils.getAeadKeySetJson());
+    when(aead.decrypt(any(byte[].class), any(byte[].class)))
+        .thenReturn(mockTinkUtils.getDecryptedKey());
+    when(aead.encrypt(any(byte[].class), any(byte[].class)))
+        .thenReturn(mockTinkUtils.getEncryptedKey());
+    String plaintext = "test_plaintext";
+    byte[] cipheredText = mockTinkUtils.getCiphertext(plaintext);
+
+    KeyFetchException exception =
+        assertThrows(
+            KeyFetchException.class,
+            () -> decryptionKeyServiceImpl.getDecrypter(UUID.randomUUID().toString()));
+
+    assertEquals(exception.getReason(), ErrorReason.UNKNOWN_ERROR);
+  }
+
+  @Test
+  public void getDecrypter_errorWithCode_UNKNOWN() throws Exception {
+    keyFetchingService.setResponse("bad test string");
+    when(aead.decrypt(any(byte[].class), any(byte[].class)))
+        .thenReturn(mockTinkUtils.getDecryptedKey());
+    when(aead.encrypt(any(byte[].class), any(byte[].class)))
+        .thenReturn(mockTinkUtils.getEncryptedKey());
+    String plaintext = "test_plaintext";
+    byte[] cipheredText = mockTinkUtils.getCiphertext(plaintext);
+
+    KeyFetchException exception =
+        assertThrows(
+            KeyFetchException.class,
+            () -> decryptionKeyServiceImpl.getDecrypter(UUID.randomUUID().toString()));
+
+    assertEquals(exception.getReason(), ErrorReason.UNKNOWN_ERROR);
+  }
+
   private static final class TestEnv extends AbstractModule {

     @Override
diff --git a/javatests/com/google/scp/operator/cpio/cryptoclient/MultiPartyDecryptionKeyServiceImplTest.java b/javatests/com/google/scp/operator/cpio/cryptoclient/MultiPartyDecryptionKeyServiceImplTest.java
index e6ed8c50d..72540987b 100644
--- a/javatests/com/google/scp/operator/cpio/cryptoclient/MultiPartyDecryptionKeyServiceImplTest.java
+++ b/javatests/com/google/scp/operator/cpio/cryptoclient/MultiPartyDecryptionKeyServiceImplTest.java
@@ -17,7 +17,10 @@
 package com.google.scp.operator.cpio.cryptoclient;

 import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertThrows;
 import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyString;
 import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
@@ -33,6 +36,11 @@ import com.google.protobuf.ByteString;
 import com.google.scp.coordinator.protos.keymanagement.shared.api.v1.EncryptionKeyProto.EncryptionKey;
 import com.google.scp.coordinator.protos.keymanagement.shared.api.v1.EncryptionKeyTypeProto.EncryptionKeyType;
 import com.google.scp.coordinator.protos.keymanagement.shared.api.v1.KeyDataProto.KeyData;
+import com.google.scp.operator.cpio.cryptoclient.DecryptionKeyService.KeyFetchException;
+import com.google.scp.operator.cpio.cryptoclient.EncryptionKeyFetchingService.EncryptionKeyFetchingServiceException;
+import com.google.scp.operator.cpio.cryptoclient.model.ErrorReason;
+import com.google.scp.shared.api.exception.ServiceException;
+import com.google.scp.shared.api.model.Code;
 import com.google.scp.shared.crypto.tink.CloudAeadSelector;
 import com.google.scp.shared.testutils.crypto.MockTinkUtils;
 import com.google.scp.shared.util.KeySplitUtil;
@@ -71,6 +79,74 @@ public class MultiPartyDecryptionKeyServiceImplTest {
             aeadServiceSecondary);
   }

+  @Test
+  public void getDecrypter_errorWithCode_NOT_FOUND() throws Exception {
+    when(coordinatorAKeyFetchingService.fetchEncryptionKey(anyString()))
+        .thenThrow(
+            new EncryptionKeyFetchingServiceException(
+                new ServiceException(Code.NOT_FOUND, "test", "test")));
+
+    KeyFetchException exception =
+        assertThrows(
+            KeyFetchException.class, () -> multiPartyDecryptionKeyServiceImpl.getDecrypter("123"));
+
+    assertEquals(exception.getReason(), ErrorReason.KEY_NOT_FOUND);
+  }
+
+  @Test
+  public void getDecrypter_errorWithCode_PERMISSION_DENIED() throws Exception {
+    when(coordinatorAKeyFetchingService.fetchEncryptionKey(anyString()))
+        .thenThrow(
+            new EncryptionKeyFetchingServiceException(
+                new ServiceException(Code.PERMISSION_DENIED, "test", "test")));
+
+    KeyFetchException exception =
+        assertThrows(
+            KeyFetchException.class, () -> multiPartyDecryptionKeyServiceImpl.getDecrypter("123"));
+
+    assertEquals(exception.getReason(), ErrorReason.PERMISSION_DENIED);
+  }
+
+  @Test
+  public void getDecrypter_errorWithCode_INTERNAL() throws Exception {
+    when(coordinatorAKeyFetchingService.fetchEncryptionKey(anyString()))
+        .thenThrow(
+            new EncryptionKeyFetchingServiceException(
+                new ServiceException(Code.INTERNAL, "test", "test")));
+
+    KeyFetchException exception =
+        assertThrows(
+            KeyFetchException.class, () -> multiPartyDecryptionKeyServiceImpl.getDecrypter("123"));
+
+    assertEquals(exception.getReason(), ErrorReason.INTERNAL);
+  }
+
+  @Test
+  public void getDecrypter_errorWithCode_default() throws Exception {
+    when(coordinatorAKeyFetchingService.fetchEncryptionKey(anyString()))
+        .thenThrow(new EncryptionKeyFetchingServiceException(new Exception()));
+
+    KeyFetchException exception =
+        assertThrows(
+            KeyFetchException.class, () -> multiPartyDecryptionKeyServiceImpl.getDecrypter("123"));
+
+    assertEquals(exception.getReason(), ErrorReason.UNKNOWN_ERROR);
+  }
+
+  @Test
+  public void getDecrypter_errorWithCode_UNKNOWN() throws Exception {
+    when(coordinatorAKeyFetchingService.fetchEncryptionKey(anyString()))
+        .thenThrow(
+            new EncryptionKeyFetchingServiceException(
+                new ServiceException(Code.UNKNOWN, "test", "test")));
+
+    KeyFetchException exception =
+        assertThrows(
+            KeyFetchException.class, () -> multiPartyDecryptionKeyServiceImpl.getDecrypter("123"));
+
+    assertEquals(exception.getReason(), ErrorReason.UNKNOWN_ERROR);
+  }
+
   @Test
   public void getDecrypter_getsDecrypterSingleKey() throws Exception {
     KeyData keyData =
diff --git a/cc/aws/proxy/BUILD b/cc/aws/proxy/BUILD
index ef42f8880..9af3430b7 100644
--- a/cc/aws/proxy/BUILD
+++ b/cc/aws/proxy/BUILD
@@ -92,7 +92,7 @@ genrule(
       bazel/cc/aws/proxy:build_container \
       bash -c '
         set -eux
-        yum install glibc-devel-2.26-60.amzn2 glibc-headers-2.26-60.amzn2 gcc-7.3.1-15.amzn2 gcc-c++-7.3.1-15.amzn2 tar git -y > /dev/null
+        yum install glibc-devel-2.26-63.amzn2 glibc-headers-2.26-63.amzn2 gcc-7.3.1-15.amzn2 gcc-c++-7.3.1-15.amzn2 tar git -y > /dev/null
         tar xf /source_code.tar -C /
         cd /scp
         bazel build \
diff --git a/java/com/google/scp/operator/cpio/distributedprivacybudgetclient/TransactionPhaseManagerImpl.java b/java/com/google/scp/operator/cpio/distributedprivacybudgetclient/TransactionPhaseManagerImpl.java
index dca7e03..285ba31 100644
--- a/java/com/google/scp/operator/cpio/distributedprivacybudgetclient/TransactionPhaseManagerImpl.java
+++ b/java/com/google/scp/operator/cpio/distributedprivacybudgetclient/TransactionPhaseManagerImpl.java
@@ -48,7 +48,7 @@
       case NOTSTARTED:
         return currentPhaseSucceeded ? TransactionPhase.BEGIN : TransactionPhase.END;
       case BEGIN:
-        return currentPhaseSucceeded ? TransactionPhase.PREPARE : TransactionPhase.END;
+        return currentPhaseSucceeded ? TransactionPhase.PREPARE : TransactionPhase.ABORT;
       case PREPARE:
         return currentPhaseSucceeded ? TransactionPhase.COMMIT : TransactionPhase.END;
       case COMMIT:
diff --git a/javatests/com/google/scp/operator/cpio/distributedprivacybudgetclient/TransactionPhaseManagerTest.java b/javatests/com/google/scp/operator/cpio/distributedprivacybudgetclient/TransactionPhaseManagerTest.java
index 90b04d0..81438f7 100644
--- a/javatests/com/google/scp/operator/cpio/distributedprivacybudgetclient/TransactionPhaseManagerTest.java
+++ b/javatests/com/google/scp/operator/cpio/distributedprivacybudgetclient/TransactionPhaseManagerTest.java
@@ -76,7 +76,7 @@
             transactionPhaseManager.proceedToNextPhase(
                 TransactionPhase.BEGIN,
                 ExecutionResult.create(ExecutionStatus.FAILURE, StatusCode.UNKNOWN)))
-        .isEqualTo(TransactionPhase.END);
+        .isEqualTo(TransactionPhase.ABORT);
     assertThat(
             transactionPhaseManager.proceedToNextPhase(
                 TransactionPhase.BEGIN,
diff --git a/java/com/google/scp/shared/api/util/BUILD b/java/com/google/scp/shared/api/util/BUILD
index 5f13a1fcb..66bc34e3f 100644
--- a/java/com/google/scp/shared/api/util/BUILD
+++ b/java/com/google/scp/shared/api/util/BUILD
@@ -24,6 +24,7 @@ java_library(
         "//java/external:apache_httpcore5",
         "//java/external:autovalue",
         "//java/external:autovalue_annotations",
+        "//java/external:aws_sts",
         "//java/external:findbugs",
         "//java/external:guava",
         "//java/external:guice",
diff --git a/java/com/google/scp/shared/api/util/HttpClientWithInterceptor.java b/java/com/google/scp/shared/api/util/HttpClientWithInterceptor.java
index 4dfa1ecc7..5e5185ffb 100644
--- a/java/com/google/scp/shared/api/util/HttpClientWithInterceptor.java
+++ b/java/com/google/scp/shared/api/util/HttpClientWithInterceptor.java
@@ -37,9 +37,11 @@ import org.apache.hc.client5.http.impl.async.HttpAsyncClients;
 import org.apache.hc.core5.http.ContentType;
 import org.apache.hc.core5.http.Header;
 import org.apache.hc.core5.http.HttpRequestInterceptor;
+import org.apache.hc.core5.http.HttpStatus;
 import org.apache.hc.core5.http.Method;
 import org.apache.hc.core5.reactor.IOReactorStatus;
 import org.apache.hc.core5.util.Timeout;
+import software.amazon.awssdk.services.sts.model.StsException;

 /**
  * This is a wrapper on top the bare-bones Apache HttpClient 5.0. Every request executed by the
@@ -51,7 +53,9 @@ public class HttpClientWithInterceptor {
   private static final Duration MAX_BACKOFF_INTERVAL = Duration.ofSeconds(30);
   private static final int BACKOFF_MULTIPLIER = 2;
   private static final int MAX_ATTEMPTS = 6;
-  private static final RetryRegistry RETRY_REGISTRY =
+
+  @VisibleForTesting
+  static final RetryRegistry RETRY_REGISTRY =
       RetryRegistry.of(
           RetryConfig.custom()
               .maxAttempts(MAX_ATTEMPTS)
@@ -62,8 +66,9 @@ public class HttpClientWithInterceptor {
               .intervalFunction(
                   IntervalFunction.ofExponentialBackoff(
                       INITIAL_BACKOFF_INTERVAL, BACKOFF_MULTIPLIER, MAX_BACKOFF_INTERVAL))
-              .retryExceptions(Exception.class)
+              .retryOnException(HttpClientWithInterceptor::retryOnExceptionPredicate)
               .build());
+
   private static final long REQUEST_TIMEOUT_DURATION = Duration.ofSeconds(60).toMillis();
   private static final RequestConfig REQUEST_CONFIG =
       RequestConfig.custom()
@@ -75,6 +80,20 @@ public class HttpClientWithInterceptor {
           .setResponseTimeout(Timeout.ofMilliseconds(REQUEST_TIMEOUT_DURATION))
           .build();

+  private static boolean retryOnExceptionPredicate(Throwable e) {
+    // If the HTTP error code is UNAUTHORIZED or FORBIDDEN in StsException, this
+    // likely means that the client is not able to get auth token from AWS STS.
+    // Don't retry in this case.
+    if (e instanceof StsException) {
+      StsException stsException = (StsException) e;
+      return stsException.statusCode() != HttpStatus.SC_UNAUTHORIZED
+          && stsException.statusCode() != HttpStatus.SC_FORBIDDEN;
+    }
+
+    // Otherwise, retry
+    return true;
+  }
+
   private final CloseableHttpAsyncClient httpClient;
   private final Retry retryConfig;

@@ -155,6 +174,28 @@ public class HttpClientWithInterceptor {
                 return httpClient.execute(httpRequest, null).get();
               })
           .apply();
+    } catch (StsException e) {
+      // The HTTP request sent by HttpClientWithInterceptor can potentially be intercepted by
+      // other HTTP interceptor, such as AwsAuthTokenInterceptor. These interceptors can
+      // potentially throws some RuntimeException. StsException is a RuntimeException
+      // that might be thrown by AwsAuthTokenInterceptor when the interceptor is not able to get
+      // auth token (e.g. when the client can't assume another AWS role).
+
+      // If the HTTP error code is UNAUTHORIZED or FORBIDDEN, don't throw IOException so that
+      // PrivacyBudgetClientImpl and TransactionEngineImpl do not retry the HTTP request. These
+      // error codes are generally not retryable within a short period of time.
+      String errorMessage =
+          e.awsErrorDetails() != null
+              ? e.awsErrorDetails().errorMessage()
+              : "Unknown error message";
+      if (e.statusCode() == HttpStatus.SC_UNAUTHORIZED) {
+        return SimpleHttpResponse.create(HttpStatus.SC_UNAUTHORIZED, errorMessage);
+      } else if (e.statusCode() == HttpStatus.SC_FORBIDDEN) {
+        return SimpleHttpResponse.create(HttpStatus.SC_FORBIDDEN, errorMessage);
+      }
+
+      // Other exception will be rethrown as IOException
+      throw new IOException(e);
     } catch (Throwable e) {
       /**
        * We wrap all exceptions coming out of this operation into an IOException because we believe
diff --git a/javatests/com/google/scp/shared/api/util/BUILD b/javatests/com/google/scp/shared/api/util/BUILD
index 2adf75ebd..c6e1e0c13 100644
--- a/javatests/com/google/scp/shared/api/util/BUILD
+++ b/javatests/com/google/scp/shared/api/util/BUILD
@@ -57,6 +57,7 @@ java_test(
         "//java/external:apache_httpclient5",
         "//java/external:apache_httpcore5",
         "//java/external:aws_auth",
+        "//java/external:aws_sts",
         "//java/external:google_truth",
         "//java/external:mockito",
         "//java/external:mockito_inline",
diff --git a/javatests/com/google/scp/shared/api/util/HttpClientWithInterceptorTest.java b/javatests/com/google/scp/shared/api/util/HttpClientWithInterceptorTest.java
index 50709b094..e92d3fbda 100644
--- a/javatests/com/google/scp/shared/api/util/HttpClientWithInterceptorTest.java
+++ b/javatests/com/google/scp/shared/api/util/HttpClientWithInterceptorTest.java
@@ -51,24 +51,16 @@ import org.junit.runners.JUnit4;
 import org.mockito.Mock;
 import org.mockito.junit.MockitoJUnit;
 import org.mockito.junit.MockitoRule;
+import software.amazon.awssdk.services.sts.model.StsException;

 @RunWith(JUnit4.class)
 public final class HttpClientWithInterceptorTest {
-
-  @Rule public final MockitoRule mockito = MockitoJUnit.rule();
-
-  @Mock CloseableHttpAsyncClient httpClient;
-  @Mock Future<SimpleHttpResponse> responseFuture;
-  private final String endpointUrl = "https://www.google.com/";
-  private final String relativePath = "phasePath";
-
-  private HttpClientWithInterceptor httpClientWithInterceptor;
-  private Header[] responseHeaders;
-
-  private final RetryRegistry retryRegistry =
+  private static final String ENDPOINT_URL = "https://www.google.com/phasePath";
+  private static final int MAX_ATTEMPTS = 4;
+  private static final RetryRegistry RETRY_REGISTRY =
       RetryRegistry.of(
-          RetryConfig.custom()
-              .maxAttempts(4)
+          RetryConfig.from(HttpClientWithInterceptor.RETRY_REGISTRY.retry("test").getRetryConfig())
+              .maxAttempts(MAX_ATTEMPTS)
               /*
                * Retries 3 times (in addition to initial attempt) with initial interval of 1s between calls.
                * Backoff interval increases exponentially between retries viz. 1s, 2s, 4s respectively
@@ -76,33 +68,40 @@ public final class HttpClientWithInterceptorTest {
               .intervalFunction(
                   IntervalFunction.ofExponentialBackoff(
                       Duration.ofMillis(500), 2, Duration.ofMillis(2000)))
-              .retryExceptions(Exception.class)
               .build());
+  private static final Header[] RESPONSE_HEADERS =
+      new BasicHeader[] {
+        new BasicHeader("resKey1", "resVal1"), new BasicHeader("resKey2", "resVal2")
+      };
+  private static final Map<String, String> REQUEST_HEADERS =
+      ImmutableMap.of("reqKey1", "reqVal1", "reqKey2", "reqVal2");
+  private static final String DUMMY_PAYLOAD = "dummy";
+
+  @Rule public final MockitoRule mockito = MockitoJUnit.rule();
+
+  @Mock private CloseableHttpAsyncClient httpClient;
+  @Mock private Future<SimpleHttpResponse> responseFuture;
+
+  private HttpClientWithInterceptor httpClientWithInterceptor;

   @Before
   public void setup() throws IOException {
     when(httpClient.getStatus()).thenReturn(IOReactorStatus.ACTIVE);
-    httpClientWithInterceptor = new HttpClientWithInterceptor(httpClient, retryRegistry);
-    this.responseHeaders =
-        new BasicHeader[] {
-          new BasicHeader("resKey1", "resVal1"), new BasicHeader("resKey2", "resVal2")
-        };
+    httpClientWithInterceptor = new HttpClientWithInterceptor(httpClient, RETRY_REGISTRY);
   }

   @Test
   public void executeGet_success() throws Exception {
     SimpleHttpResponse response1 = SimpleHttpResponse.create(HttpStatus.SC_OK, "");
-    response1.setHeaders(responseHeaders);
-    Map<String, String> requestHeaders =
-        ImmutableMap.of("reqKey1", "reqVal1", "reqKey2", "reqVal2");
+    response1.setHeaders(RESPONSE_HEADERS);
     when(httpClient.execute(any(), any())).thenReturn(responseFuture);
     when(responseFuture.get()).thenReturn(response1);

     HttpClientResponse response =
-        httpClientWithInterceptor.executeGet(endpointUrl + relativePath, requestHeaders);
+        httpClientWithInterceptor.executeGet(ENDPOINT_URL, REQUEST_HEADERS);

     assertThat(response.statusCode()).isEqualTo(HttpStatus.SC_OK);
-    assertThat(response.headers()).isEqualTo(headerArrayToMap(responseHeaders));
+    assertThat(response.headers()).isEqualTo(headerArrayToMap(RESPONSE_HEADERS));
     assertThat(response.responseBody()).isEmpty();
     verify(httpClient, never()).start();
     verify(httpClient, times(1)).execute(any(), any());
@@ -111,19 +110,16 @@ public final class HttpClientWithInterceptorTest {

   @Test
   public void executePost_success() throws Exception {
-    String payload = "dummy payload string";
     SimpleHttpResponse response1 = SimpleHttpResponse.create(HttpStatus.SC_OK, "");
-    response1.setHeaders(responseHeaders);
-    Map<String, String> requestHeaders =
-        ImmutableMap.of("reqKey1", "reqVal1", "reqKey2", "reqVal2");
+    response1.setHeaders(RESPONSE_HEADERS);
     when(httpClient.execute(any(), any())).thenReturn(responseFuture);
     when(responseFuture.get()).thenReturn(response1);

     HttpClientResponse response =
-        httpClientWithInterceptor.executePost(endpointUrl + relativePath, payload, requestHeaders);
+        httpClientWithInterceptor.executePost(ENDPOINT_URL, DUMMY_PAYLOAD, REQUEST_HEADERS);

     assertThat(response.statusCode()).isEqualTo(HttpStatus.SC_OK);
-    assertThat(response.headers()).isEqualTo(headerArrayToMap(responseHeaders));
+    assertThat(response.headers()).isEqualTo(headerArrayToMap(RESPONSE_HEADERS));
     assertThat(response.responseBody()).isEmpty();
     verify(httpClient, never()).start();
     verify(httpClient, times(1)).execute(any(), any());
@@ -132,21 +128,18 @@ public final class HttpClientWithInterceptorTest {

   @Test
   public void executePost_success_afterRetry() throws Exception {
-    String payload = "dummy payload string";
     SimpleHttpResponse response1 = SimpleHttpResponse.create(HttpStatus.SC_OK, "");
-    response1.setHeaders(responseHeaders);
-    Map<String, String> requestHeaders =
-        ImmutableMap.of("reqKey1", "reqVal1", "reqKey2", "reqVal2");
+    response1.setHeaders(RESPONSE_HEADERS);
     ExecutionException exception =
         new ExecutionException(new ConnectionRequestTimeoutException("Connection timed out"));
     when(httpClient.execute(any(), any())).thenReturn(responseFuture);
     when(responseFuture.get()).thenThrow(exception, exception).thenReturn(response1);

     HttpClientResponse response =
-        httpClientWithInterceptor.executePost(endpointUrl + relativePath, payload, requestHeaders);
+        httpClientWithInterceptor.executePost(ENDPOINT_URL, DUMMY_PAYLOAD, REQUEST_HEADERS);

     assertThat(response.statusCode()).isEqualTo(HttpStatus.SC_OK);
-    assertThat(response.headers()).isEqualTo(headerArrayToMap(responseHeaders));
+    assertThat(response.headers()).isEqualTo(headerArrayToMap(RESPONSE_HEADERS));
     assertThat(response.responseBody()).isEmpty();
     verify(httpClient, never()).start();
     verify(httpClient, times(3)).execute(any(), any());
@@ -156,9 +149,6 @@ public final class HttpClientWithInterceptorTest {
   @Test
   public void executePost_failure_retriesExhausted_checkedException()
       throws ExecutionException, InterruptedException {
-    String payload = "dummy payload string";
-    Map<String, String> requestHeaders =
-        ImmutableMap.of("reqKey1", "reqVal1", "reqKey2", "reqVal2");
     when(httpClient.execute(any(), any())).thenReturn(responseFuture);
     when(responseFuture.get())
         .thenThrow(new ExecutionException(new RuntimeException("Connection timed out")));
@@ -168,23 +158,20 @@ public final class HttpClientWithInterceptorTest {
             IOException.class,
             () ->
                 httpClientWithInterceptor.executePost(
-                    endpointUrl + relativePath, payload, requestHeaders));
+                    ENDPOINT_URL, DUMMY_PAYLOAD, REQUEST_HEADERS));

     IOException expectedException =
         new IOException(
             "java.util.concurrent.ExecutionException: java.lang.RuntimeException: Connection timed"
                 + " out");
     assertThat(actualException.getMessage()).isEqualTo(expectedException.getMessage());
-    verify(httpClient, times(4)).execute(any(), any());
-    verify(responseFuture, times(4)).get();
+    verify(httpClient, times(MAX_ATTEMPTS)).execute(any(), any());
+    verify(responseFuture, times(MAX_ATTEMPTS)).get();
   }

   @Test
   public void executePost_failure_retriesExhausted_runtimeException()
       throws ExecutionException, InterruptedException {
-    String payload = "dummy payload string";
-    Map<String, String> requestHeaders =
-        ImmutableMap.of("reqKey1", "reqVal1", "reqKey2", "reqVal2");
     when(httpClient.execute(any(), any())).thenReturn(responseFuture);
     when(responseFuture.get()).thenThrow(new RuntimeException("Connection timed out"));

@@ -193,13 +180,41 @@ public final class HttpClientWithInterceptorTest {
             IOException.class,
             () ->
                 httpClientWithInterceptor.executePost(
-                    endpointUrl + relativePath, payload, requestHeaders));
+                    ENDPOINT_URL, DUMMY_PAYLOAD, REQUEST_HEADERS));

     IOException expectedException =
         new IOException("java.lang.RuntimeException: Connection timed out");
     assertThat(actualException.getMessage()).isEqualTo(expectedException.getMessage());
-    verify(httpClient, times(4)).execute(any(), any());
-    verify(responseFuture, times(4)).get();
+    verify(httpClient, times(MAX_ATTEMPTS)).execute(any(), any());
+    verify(responseFuture, times(MAX_ATTEMPTS)).get();
+  }
+
+  @Test
+  public void executePost_failure_unauthorizedAwsStsException()
+      throws IOException, ExecutionException, InterruptedException {
+    when(httpClient.execute(any(), any())).thenReturn(responseFuture);
+    when(responseFuture.get())
+        .thenThrow(StsException.builder().statusCode(HttpStatus.SC_UNAUTHORIZED).build());
+
+    HttpClientResponse response =
+        httpClientWithInterceptor.executePost(ENDPOINT_URL, DUMMY_PAYLOAD, REQUEST_HEADERS);
+    assertThat(response.statusCode()).isEqualTo(HttpStatus.SC_UNAUTHORIZED);
+    verify(httpClient, times(1)).execute(any(), any());
+    verify(responseFuture, times(1)).get();
+  }
+
+  @Test
+  public void executePost_failure_forbiddenAwsStsException()
+      throws IOException, ExecutionException, InterruptedException {
+    when(httpClient.execute(any(), any())).thenReturn(responseFuture);
+    when(responseFuture.get())
+        .thenThrow(StsException.builder().statusCode(HttpStatus.SC_FORBIDDEN).build());
+
+    HttpClientResponse response =
+        httpClientWithInterceptor.executePost(ENDPOINT_URL, DUMMY_PAYLOAD, REQUEST_HEADERS);
+    assertThat(response.statusCode()).isEqualTo(HttpStatus.SC_FORBIDDEN);
+    verify(httpClient, times(1)).execute(any(), any());
+    verify(responseFuture, times(1)).get();
   }

   @Test
@@ -207,7 +222,7 @@ public final class HttpClientWithInterceptorTest {
     when(httpClient.getStatus()).thenReturn(IOReactorStatus.INACTIVE);
     doNothing().when(httpClient).start();

-    httpClientWithInterceptor = new HttpClientWithInterceptor(httpClient, retryRegistry);
+    httpClientWithInterceptor = new HttpClientWithInterceptor(httpClient, RETRY_REGISTRY);

     verify(httpClient, times(1)).start();
   }
--
2.41.0.162.gfafddb0af9-goog
diff --git a/java/com/google/scp/shared/api/util/HttpClientWithInterceptor.java b/java/com/google/scp/shared/api/util/HttpClientWithInterceptor.java
index 5e5185ffb..a59ad769f 100644
--- a/java/com/google/scp/shared/api/util/HttpClientWithInterceptor.java
+++ b/java/com/google/scp/shared/api/util/HttpClientWithInterceptor.java
@@ -17,6 +17,7 @@
 package com.google.scp.shared.api.util;

 import com.google.common.annotations.VisibleForTesting;
+import com.google.common.collect.ImmutableSet;
 import com.google.inject.Inject;
 import io.github.resilience4j.core.IntervalFunction;
 import io.github.resilience4j.retry.Retry;
@@ -54,10 +55,20 @@ public class HttpClientWithInterceptor {
   private static final int BACKOFF_MULTIPLIER = 2;
   private static final int MAX_ATTEMPTS = 6;

+  private static final ImmutableSet<Integer> RETRYABLE_HTTP_STATUS_CODES =
+      ImmutableSet.of(
+          HttpStatus.SC_REQUEST_TIMEOUT, // 408
+          HttpStatus.SC_TOO_MANY_REQUESTS, // 429
+          HttpStatus.SC_INTERNAL_SERVER_ERROR, // 500
+          HttpStatus.SC_BAD_GATEWAY, // 502
+          HttpStatus.SC_SERVICE_UNAVAILABLE, // 503
+          HttpStatus.SC_GATEWAY_TIMEOUT // 504
+          );
+
   @VisibleForTesting
   static final RetryRegistry RETRY_REGISTRY =
       RetryRegistry.of(
-          RetryConfig.custom()
+          RetryConfig.<SimpleHttpResponse>custom()
               .maxAttempts(MAX_ATTEMPTS)
               /*
                * Retries 5 times (in addition to initial attempt) with initial interval of 2s between calls.
@@ -67,6 +78,7 @@ public class HttpClientWithInterceptor {
                   IntervalFunction.ofExponentialBackoff(
                       INITIAL_BACKOFF_INTERVAL, BACKOFF_MULTIPLIER, MAX_BACKOFF_INTERVAL))
               .retryOnException(HttpClientWithInterceptor::retryOnExceptionPredicate)
+              .retryOnResult(response -> RETRYABLE_HTTP_STATUS_CODES.contains(response.getCode()))
               .build());

   private static final long REQUEST_TIMEOUT_DURATION = Duration.ofSeconds(60).toMillis();
@@ -169,10 +181,7 @@ public class HttpClientWithInterceptor {
   private SimpleHttpResponse executeRequest(SimpleHttpRequest httpRequest) throws IOException {
     try {
       return Retry.decorateCheckedSupplier(
-              retryConfig,
-              () -> {
-                return httpClient.execute(httpRequest, null).get();
-              })
+              retryConfig, () -> httpClient.execute(httpRequest, null).get())
           .apply();
     } catch (StsException e) {
       // The HTTP request sent by HttpClientWithInterceptor can potentially be intercepted by
diff --git a/javatests/com/google/scp/shared/api/util/HttpClientWithInterceptorTest.java b/javatests/com/google/scp/shared/api/util/HttpClientWithInterceptorTest.java
index e92d3fbda..8c85891ad 100644
--- a/javatests/com/google/scp/shared/api/util/HttpClientWithInterceptorTest.java
+++ b/javatests/com/google/scp/shared/api/util/HttpClientWithInterceptorTest.java
@@ -127,7 +127,7 @@ public final class HttpClientWithInterceptorTest {
   }

   @Test
-  public void executePost_success_afterRetry() throws Exception {
+  public void executePost_failureWithException_success_afterRetry() throws Exception {
     SimpleHttpResponse response1 = SimpleHttpResponse.create(HttpStatus.SC_OK, "");
     response1.setHeaders(RESPONSE_HEADERS);
     ExecutionException exception =
@@ -217,6 +217,43 @@ public final class HttpClientWithInterceptorTest {
     verify(responseFuture, times(1)).get();
   }

+  @Test
+  public void executePost_failureWithRetryableHttpCode_retriesExhausted()
+      throws ExecutionException, InterruptedException, IOException {
+    String payload = "dummy payload string";
+    Map<String, String> requestHeaders =
+        ImmutableMap.of("reqKey1", "reqVal1", "reqKey2", "reqVal2");
+    when(httpClient.execute(any(), any())).thenReturn(responseFuture);
+    when(responseFuture.get())
+        .thenReturn(SimpleHttpResponse.create(HttpStatus.SC_INTERNAL_SERVER_ERROR));
+
+    HttpClientResponse actualResponse =
+        httpClientWithInterceptor.executePost(ENDPOINT_URL, payload, requestHeaders);
+
+    assertThat(actualResponse.statusCode()).isEqualTo(HttpStatus.SC_INTERNAL_SERVER_ERROR);
+    verify(httpClient, times(4)).execute(any(), any());
+    verify(responseFuture, times(4)).get();
+  }
+
+  @Test
+  public void executePost_failureWithRetryableHttpCode_success_afterRetry()
+      throws ExecutionException, InterruptedException, IOException {
+    String payload = "dummy payload string";
+    Map<String, String> requestHeaders =
+        ImmutableMap.of("reqKey1", "reqVal1", "reqKey2", "reqVal2");
+    when(httpClient.execute(any(), any())).thenReturn(responseFuture);
+    SimpleHttpResponse failureResponse = SimpleHttpResponse.create(HttpStatus.SC_BAD_GATEWAY);
+    SimpleHttpResponse successResponse = SimpleHttpResponse.create(HttpStatus.SC_OK);
+    when(responseFuture.get()).thenReturn(failureResponse, failureResponse, successResponse);
+
+    HttpClientResponse actualResponse =
+        httpClientWithInterceptor.executePost(ENDPOINT_URL, payload, requestHeaders);
+
+    assertThat(actualResponse.statusCode()).isEqualTo(HttpStatus.SC_OK);
+    verify(httpClient, times(3)).execute(any(), any());
+    verify(responseFuture, times(3)).get();
+  }
+
   @Test
   public void startsClientIfNotActive() {
     when(httpClient.getStatus()).thenReturn(IOReactorStatus.INACTIVE);
--
2.41.0.162.gfafddb0af9-goog
diff --git a/java/com/google/scp/shared/aws/credsprovider/AwsSessionCredentialsProvider.java b/java/com/google/scp/shared/aws/credsprovider/AwsSessionCredentialsProvider.java
--- a/java/com/google/scp/shared/aws/credsprovider/AwsSessionCredentialsProvider.java	(revision 21a8053a3b0c75e9522126b8051f5260ffba9d8b)
+++ b/java/com/google/scp/shared/aws/credsprovider/AwsSessionCredentialsProvider.java	(revision 62bd4ed9bcd33143db455ac5dc4bd20764b99b36)
@@ -16,16 +16,65 @@

 package com.google.scp.shared.aws.credsprovider;

+import java.lang.ref.Cleaner;
+import java.lang.ref.Cleaner.Cleanable;
+import java.util.Optional;
+import java.util.function.Supplier;
 import software.amazon.awssdk.auth.credentials.AwsCredentialsProvider;
 import software.amazon.awssdk.auth.credentials.AwsSessionCredentials;
+import software.amazon.awssdk.services.sts.model.Credentials;
+import software.amazon.awssdk.utils.SdkAutoCloseable;
+
+/**
+ * An implementation of {@link AwsCredentialsProvider} that provides {@link AwsSessionCredentials}
+ * credentials by wrapping {@link AwsCredentialsProvider} that is expected to only provide {@link
+ * AwsSessionCredentials} and implicitly asserts on that expectation.
+ */
+public abstract class AwsSessionCredentialsProvider
+    implements AwsCredentialsProvider, SdkAutoCloseable {
+
+  private static final Cleaner cleaner = Cleaner.create();
+
+  private final AwsCredentialsProvider credentialsProvider;
+  private final Supplier<AwsSessionCredentials> fallback;
+  private final Optional<Cleanable> cleanable;

-/** Interface for fetching temporary AWS credentials (AccessKeyId, SecretAccessKey, SessionToken) */
-public interface AwsSessionCredentialsProvider extends AwsCredentialsProvider {
+  /**
+   * @param credentialsProvider Known {@link AwsSessionCredentials} providing provider.
+   * @param fallback Fallback {@link Credentials} supplier when the <code>credentialsProvider</code>
+   *     does not provide the expected {@link AwsSessionCredentials}.
+   */
+  protected AwsSessionCredentialsProvider(
+      AwsCredentialsProvider credentialsProvider, Supplier<Credentials> fallback) {
+    this.credentialsProvider = credentialsProvider;
+    this.fallback = () -> asSessionCredentials(fallback.get());
+    this.cleanable =
+        Optional.of(credentialsProvider)
+            .filter(SdkAutoCloseable.class::isInstance)
+            .map(SdkAutoCloseable.class::cast)
+            .map(provider -> cleaner.register(this, provider::close));
+  }
+
+  private static AwsSessionCredentials asSessionCredentials(Credentials credentials) {
+    return AwsSessionCredentials.create(
+        credentials.accessKeyId(), credentials.secretAccessKey(), credentials.sessionToken());
+  }

   /**
    * Returns a set of temporary credentials for the configured Role.
    *
    * <p>Credentials should be valid for at least 60 seconds from when provideCredentials is invoked.
    */
-  public AwsSessionCredentials resolveCredentials();
+  public AwsSessionCredentials resolveCredentials() {
+    var credentials = credentialsProvider.resolveCredentials();
+    if (credentials instanceof AwsSessionCredentials) {
+      return (AwsSessionCredentials) credentials;
+    }
+    return fallback.get();
+  }
+
+  @Override
+  public void close() {
+    cleanable.ifPresent(Cleanable::clean);
+  }
 }
Index: java/com/google/scp/shared/aws/credsprovider/BUILD
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/java/com/google/scp/shared/aws/credsprovider/BUILD b/java/com/google/scp/shared/aws/credsprovider/BUILD
--- a/java/com/google/scp/shared/aws/credsprovider/BUILD	(revision 21a8053a3b0c75e9522126b8051f5260ffba9d8b)
+++ b/java/com/google/scp/shared/aws/credsprovider/BUILD	(revision 62bd4ed9bcd33143db455ac5dc4bd20764b99b36)
@@ -21,6 +21,8 @@
         "//java/external:aws_auth",
         "//java/external:aws_regions",
         "//java/external:aws_sts",
+        "//java/external:aws_utils",
         "//java/external:guava",
+        "//java/external:javax_inject",
     ],
 )
Index: java/com/google/scp/shared/aws/credsprovider/SelfAwsSessionCredentialsProvider.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/java/com/google/scp/shared/aws/credsprovider/SelfAwsSessionCredentialsProvider.java b/java/com/google/scp/shared/aws/credsprovider/SelfAwsSessionCredentialsProvider.java
--- a/java/com/google/scp/shared/aws/credsprovider/SelfAwsSessionCredentialsProvider.java	(revision 21a8053a3b0c75e9522126b8051f5260ffba9d8b)
+++ b/java/com/google/scp/shared/aws/credsprovider/SelfAwsSessionCredentialsProvider.java	(revision 62bd4ed9bcd33143db455ac5dc4bd20764b99b36)
@@ -17,9 +17,11 @@
 package com.google.scp.shared.aws.credsprovider;

 import java.util.Optional;
+import javax.inject.Singleton;
 import software.amazon.awssdk.auth.credentials.AwsCredentialsProvider;
 import software.amazon.awssdk.auth.credentials.AwsSessionCredentials;
 import software.amazon.awssdk.services.sts.StsClient;
+import software.amazon.awssdk.services.sts.auth.StsGetSessionTokenCredentialsProvider;

 /**
  * AWS Session credentials provider which returns the current credentials if they are already
@@ -36,11 +38,11 @@
  * do not have a session token and temporary credentials providers (e.g. instance profile
  * credentials) which have a session token and cannot be used to directly fetch new session tokens.
  */
-public final class SelfAwsSessionCredentialsProvider implements AwsSessionCredentialsProvider {
+@Singleton
+public final class SelfAwsSessionCredentialsProvider extends AwsSessionCredentialsProvider {
   /** Duration for which requested temporary credentials should be valid. */
   private static final int DURATION_SECONDS = 1000;

-  private final StsClient stsClient;
   private final AwsCredentialsProvider credentialsProvider;

   /**
@@ -50,13 +52,23 @@
    */
   public SelfAwsSessionCredentialsProvider(
       AwsCredentialsProvider processCredentialsProvider, StsClient stsClient) {
-    this.stsClient = stsClient;
+    super(
+        // This provider will fail if stsClient is already configured to use session credentials
+        // because session credentials cannot be used with getSessionToken.
+        StsGetSessionTokenCredentialsProvider.builder()
+            .stsClient(stsClient)
+            .refreshRequest(request -> request.durationSeconds(DURATION_SECONDS))
+            .build(),
+        () ->
+            stsClient
+                .getSessionToken(request -> request.durationSeconds(DURATION_SECONDS))
+                .credentials());
     this.credentialsProvider = processCredentialsProvider;
   }

   @Override
   public AwsSessionCredentials resolveCredentials() {
-    return resolveProcessCredentials().orElseGet(this::fetchNewSessionCredentials);
+    return resolveProcessCredentials().orElseGet(super::resolveCredentials);
   }

   /** Resolves current credentials and returns them if they are session credentials. */
@@ -68,16 +80,4 @@
     }
     return Optional.empty();
   }
-
-  /**
-   * Fetches temporary credentials using STS. Will fail if stsClient is already configured to use
-   * session credentials because session credentials cannot be used with getSessionToken.
-   */
-  private AwsSessionCredentials fetchNewSessionCredentials() {
-    var credentials =
-        stsClient.getSessionToken(req -> req.durationSeconds(DURATION_SECONDS)).credentials();
-
-    return AwsSessionCredentials.create(
-        credentials.accessKeyId(), credentials.secretAccessKey(), credentials.sessionToken());
-  }
 }
Index: java/com/google/scp/shared/aws/credsprovider/StsAwsSessionCredentialsProvider.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/java/com/google/scp/shared/aws/credsprovider/StsAwsSessionCredentialsProvider.java b/java/com/google/scp/shared/aws/credsprovider/StsAwsSessionCredentialsProvider.java
--- a/java/com/google/scp/shared/aws/credsprovider/StsAwsSessionCredentialsProvider.java	(revision 21a8053a3b0c75e9522126b8051f5260ffba9d8b)
+++ b/java/com/google/scp/shared/aws/credsprovider/StsAwsSessionCredentialsProvider.java	(revision 62bd4ed9bcd33143db455ac5dc4bd20764b99b36)
@@ -16,49 +16,45 @@

 package com.google.scp.shared.aws.credsprovider;

-import software.amazon.awssdk.auth.credentials.AwsSessionCredentials;
+import javax.inject.Singleton;
 import software.amazon.awssdk.services.sts.StsClient;
-import software.amazon.awssdk.services.sts.model.AssumeRoleRequest;
-import software.amazon.awssdk.services.sts.model.Credentials;
+import software.amazon.awssdk.services.sts.auth.StsAssumeRoleCredentialsProvider;

 /**
  * Provides temporary AWS credentials using AWS Security Token Service (STS)
  *
  * <p>The credentials provided by this class are fetched directly from STS as oppposed to being
  * reused from the credentials available from e.g. the EC2 instance metadata.
- *
- * <p>TODO: implement credential caching.
  */
-public final class StsAwsSessionCredentialsProvider implements AwsSessionCredentialsProvider {
+@Singleton
+public final class StsAwsSessionCredentialsProvider extends AwsSessionCredentialsProvider {

   /** Duration for which requested credentials should be valid. */
   private static final int DURATION_SECONDS = 1000;

-  private final StsClient stsClient;
-  private final String roleArn;
-  private final String sessionName;
-
   /**
    * @param roleArn the role to assume and provide credentials for.
    * @param sessionName The name of the session associated with the credentials (visible in logs)
    */
   public StsAwsSessionCredentialsProvider(StsClient stsClient, String roleArn, String sessionName) {
-    this.stsClient = stsClient;
-    this.roleArn = roleArn;
-    this.sessionName = sessionName;
-  }
-
-  @Override
-  public AwsSessionCredentials resolveCredentials() {
-    AssumeRoleRequest request =
-        AssumeRoleRequest.builder()
-            .durationSeconds(DURATION_SECONDS)
-            .roleArn(roleArn)
-            .roleSessionName(sessionName)
-            .build();
-    Credentials credentials = stsClient.assumeRole(request).credentials();
-
-    return AwsSessionCredentials.create(
-        credentials.accessKeyId(), credentials.secretAccessKey(), credentials.sessionToken());
+    super(
+        StsAssumeRoleCredentialsProvider.builder()
+            .stsClient(stsClient)
+            .refreshRequest(
+                request ->
+                    request
+                        .durationSeconds(DURATION_SECONDS)
+                        .roleArn(roleArn)
+                        .roleSessionName(sessionName))
+            .build(),
+        () ->
+            stsClient
+                .assumeRole(
+                    request ->
+                        request
+                            .durationSeconds(DURATION_SECONDS)
+                            .roleArn(roleArn)
+                            .roleSessionName(sessionName))
+                .credentials());
   }
 }
